# What Is A Monorepo?

A monorepo, short for monolithic repository, is a software development strategy where code for many projects is stored in the same repository. This approach is in contrast to having one repository per project, which is known as a polyrepo approach.

<details>
<summary>ðŸ’ª Challenge</summary>

Consider the following questions:

1. What are some potential benefits of orchestrating a monorepo? Think about aspects like code sharing, dependency management, and project synchronization.

2. What advantages might you gain from organizing your code into small, independent, and self-contained components with well-defined boundaries and interfaces? Consider factors like modularity, code maintainability, and testing.

Try to answer these questions based on your understanding of monorepos and code organization.

</details>

<details>
<summary>ðŸŒ± Solution</summary>

### Scaling a Codebase

When it comes to scaling a codebase, companies face a crucial decision. They can either break their codebase into smaller, separate repositories (a strategy known as polyrepo), or they can consolidate their codebase into a single repository (a strategy known as monorepo).

### Polyrepo Strategy

![](../resources/images/001-polyrepo-strategy.png)

In a polyrepo approach, each application or service is maintained in its own separate repository. For instance, your main application would reside in one repository, while any shared services or libraries it uses, such as authentication or design systems, are stored in their respective repositories. These shared components are typically published to a package manager like NPM, allowing them to be easily included and updated across various projects.

> In simple terms, a polyrepo approach means using a separate repository for each team, application, or project, with each one having its own build process.

### Monorepo Strategy

![](../resources/images/002-monorepo-stratery.png)

A monorepo is a single repository that houses the code for multiple projects. These projects are distinct yet interconnected, and they often include related JavaScript or TypeScript packages. The projects within a monorepo can range from low-level utilities to high-level web user interfaces.

> The only difference is where you put your code. Itâ€™s probably a good idea to organize your code into small independent and self-contained components with well-defined boundaries and interfaces.

### Monorepo vs Monolith Clarified

A common misconception is that a monorepo and a monolithic application are the same. However, they differ significantly in structure. A monolithic application is essentially one large codebase that encompasses all its projects and components. On the other hand, a monorepo serves as a single repository that contains multiple, independent projects. This setup supports a modular approach to development, allowing each project to be developed separately yet still under the umbrella of a single version control system.

</details>

# Introduction to pnpm

pnpm is a fast, efficient, and powerful package manager for JavaScript. It's an excellent alternative to npm, offering better monorepo tools and efficient package management. This section will guide you through the installation and usage of pnpm, helping you orchestrate a monorepo efficiently.

Why are we choosing this tool? It's an alternative to npm and the monorepo tools provided by pnpm are significantly better and more efficient. Some tools have too much bloat! With pnpm, you can orchestrate a monorepo efficiently. This is a workshop on using pnpm efficently as well!

<details>
<summary>ðŸ’ª Challenge</summary>

Your task is to install pnpm. To verify your installation, check the version of pnpm installed. It should be `9` or the latest version. Can you complete this challenge?

</details>

<details>
<summary>ðŸ§° Resources</summary>

- [Motivation behind pnpm](https://pnpm.io/motivation)
- [Feature comparison between npm, yarn, and pnpm](https://pnpm.io/feature-comparison)
- [Installation guide for pnpm](https://pnpm.io/installation)

</details>

<details>

<summary>ðŸŒ± Solution</summary>

To install pnpm, use the following command:

```bash
brew install pnpm
```

After installation, ensure that you're using pnpm `9` or the latest version. You can do this by checking the installed version of pnpm:

```bash
pnpm --version
```

The output should be `9.0.6` or a later version.

```bash
9.0.6
```

</details>

# Creating a Monorepo

We are going to focus on a barebones setup. We are not going to introduce any compilers, so that we can get the fundamentals down. Then, we can apply these to any project, whether that's a React, Svelte, or Vue framework.

Task: Create package.json files and folders following the monorepo structure. Create a pnpm-workspace.yaml outlining where pnpm will look for submodules of our monorepo.

Let's start by creating an empty folder. Navigate to the desired location and run the command `mkdir monorepo-forest` to create a new folder.

Next, navigate into the newly created folder using `cd project-name`.

Now, initialize a new project with `pnpm init`. This command will create a `package.json` file in your project directory. This file is crucial as it manages the project's dependencies and scripts.

Steps:

1. From the terminal:

Task: Update the package or submodule package.json. Create a script to run a JavaScript file. Run the script at the root of the project.

# Multiple Package And Recursive Commands

Task: Create a second package and run scripts recursively. Orchestrate commands at the individual level or all of them at once.

# Sharing Code Between Projects

Task: Run code from one package inside another package. Make each project into an ESM project. Install package number 2 into package 1. Run `pnpm install` and take a look at files in the node_modules folder.

Note: ESM stands for ECMAScript Modules. It's a standard for working with modules in JavaScript. Modules are reusable pieces of code that can be exported from one program and imported for use in another program. ESM is the official standard format to package JavaScript code for reuse. Modules are defined using a variety of import and export statements.

This is the core of working in a monorepo!

# Versioning and Workspace Pinning

Task: Change the code of the second package and update how it's being called in the first package. Enable pnpm to always grab the latest version of each package using `workspace:`

https://pnpm.io/workspaces

# Pinning Node and pnpm Versions

Task: Specify the version of Node and pnpm.

https://pnpm.io/package_json

# Installing Packages

Task: Install a third party dependency using pnpm. Not at the root of the workspace but at the specific project. Use the filter command of pnpm. Test that it runs correctly. Figure out if you get access to use this in other projects where the package is not installed. Why didn't it work?

```js
import snakeCase from 'just-snake-case'
;`snakeCase('the quick brown fox'); // 'the_quick_brown_fox'`
```

https://www.npmjs.com/package/just-snake-case

# Updating Packages and Version Syncing

Task: Versions can get complicated. How do we keep our versions up to date in our monorepo? Your task is to implement a script to update all your packages interactively. Update the dependencies to their latest stable version as determined by their latest tags.

https://pnpm.io/cli/update

# Installing Packages Into the Root

Task: Add this package at the root of the project using -w flag. Use this package in your project! You might think that this is a good approach for keeping dependencies up to date. It's not always the right decision to install it in the individual packages. There's no right answer for either installing packages at the root level or individual packages, it depends on your needs.

https://www.npmjs.com/package/just-kebab-case

# Cleaning node_modules

Task: Use the clean script using the find command and delete all node modules recursively.This is usefull if something is wrong and you need to install everything again.

# Understanding dependencies

Task: Use the pnpm list This command will output all the versions of packages that are installed, as well as their dependencies, in a tree-structure. Now use the why command Shows all packages that depend on the specified packag

https://pnpm.io/cli/why

https://pnpm.io/cli/list
import { version } from "react"
