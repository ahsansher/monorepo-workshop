## 00. Monorepos and Forests 🌳

As a trail runner who loves exploring Forest Park in Portland, I've found a compelling metaphor for understanding Monorepos - the forest itself!

- Monorepos, like forests, thrive on interconnectedness. Just as trees in a forest are linked through a "wood-wide web" of fungal filaments, multiple projects coexist within a single monorepo, promoting efficient resource sharing and management.
- Trees communicate and adapt based on shared signals. Similarly, in a monorepo, changes in one part are instantly accessible to all other parts, enabling seamless collaboration.
- Monorepos simplify dependency management. All projects share the same dependencies, much like trees in a forest sharing water and nutrients through their interconnected network.
- The resilience of a monorepo mirrors that of a forest. The failure of one project doesn't mean disaster for the entire system, just as older "mother trees" nurture younger ones, ensuring the forest's survival and sustainability.

Join me as we traverse the forest of monorepos, discovering its interconnected pathways and hidden treasures!

<details>
<summary>Snapshot: Me running through Forest Park 👟</summary>

![](../resources/images/000-intro-monorepos-forests.jpg)

</details>

## 01. Monorepo Architecture

A monorepo, short for monolithic repository, is a software development strategy where code for many projects is stored in the same repository. This approach is in contrast to having one repository per project, which is known as a polyrepo approach.

<details>
<summary>💪 Challenge</summary>

Try to answer these questions based on your understanding of monorepos and code organization.

1. What are some potential benefits of orchestrating a monorepo? Think about aspects like code sharing, dependency management, and project synchronization.

2. What advantages might you gain from organizing your code into small, independent, and self-contained components with well-defined boundaries and interfaces? Consider factors like modularity, code maintainability, and testing.

</details>

<details>
<summary>🌱 Solution</summary>

### Scaling a Codebase

When it comes to scaling a codebase, companies face a crucial decision. They can either break their codebase into smaller, separate repositories (a strategy known as polyrepo), or they can consolidate their codebase into a single repository (a strategy known as monorepo).

### Polyrepo Strategy

![](../resources/images/001-polyrepo-strategy.png)

In a polyrepo approach, each application or service is maintained in its own separate repository. For instance, your main application would reside in one repository, while any shared services or libraries it uses, such as authentication or design systems, are stored in their respective repositories. These shared components are typically published to a package manager like NPM, allowing them to be easily included and updated across various projects.

> In simple terms, a polyrepo approach means using a separate repository for each team, application, or project, with each one having its own build process.

### Monorepo Strategy

![](../resources/images/002-monorepo-stratery.png)

A monorepo is a single repository that houses the code for multiple projects. These projects are distinct yet interconnected, and they often include related JavaScript or TypeScript packages. The projects within a monorepo can range from low-level utilities to high-level web user interfaces.

> The only difference is where you put your code. It’s probably a good idea to organize your code into small independent and self-contained components with well-defined boundaries and interfaces.

### Monorepo vs Monolith Clarified

A common misconception is that a monorepo and a monolithic application are the same. However, they differ significantly in structure. A monolithic application is essentially one large codebase that encompasses all its projects and components. On the other hand, a monorepo serves as a single repository that contains multiple, independent projects. This setup supports a modular approach to development, allowing each project to be developed separately yet still under the umbrella of a single version control system.

</details>

## 02. Introduction to PNPM

pnpm is a fast, efficient, and powerful package manager for JavaScript. It's an excellent alternative to npm, offering better monorepo tools and efficient package management. This section will guide you through the installation and usage of pnpm, helping you orchestrate a monorepo efficiently.

Why are we choosing this tool? It's an alternative to npm and the monorepo tools provided by pnpm are significantly better and more efficient. Some tools have too much bloat! With pnpm, you can orchestrate a monorepo efficiently. This is a workshop on using pnpm efficently as well!

<details>
<summary>💪 Challenge</summary>

1. Your challange is to install pnpm. To verify your installation, check the version of pnpm installed. It should be `9` or the latest version.

</details>

<details>
<summary>🧰 Resources</summary>

- [Motivation behind pnpm](https://pnpm.io/motivation)
- [Feature comparison between npm, yarn, and pnpm](https://pnpm.io/feature-comparison)
- [Installation guide for pnpm](https://pnpm.io/installation)

</details>

<details>

<summary>🌱 Solution</summary>
To install pnpm, use the following command:

```bash
brew install pnpm
```

After installation, ensure that you're using pnpm `9` or the latest version. You can do this by checking the installed version of pnpm:

```bash
pnpm --version
```

The output should be `9.0.6` or a later version.

```bash
9.0.6
```

</details>

## 03. Assembling a Monorepo from Scratch

In this section, we'll concentrate on setting up a basic monorepo structure. We'll deliberately avoid introducing any compilers or tooling at this point, allowing us to focus on understanding the core principles of orchestrating a monorepo from the ground up. Once we've grasped these fundamental concepts, we'll be able to apply them to any project, irrespective of the framework used, be it React, Svelte, Vue, or others.

<details>
<summary>💪 Challenge</summary>

Your task is to create a monorepo using pnpm workspaces.

1. In the 01-start directory, create a new folder following monorepo conventions.
2. Inside this folder, initialize a new package.
3. Create an index.js file in your new package.
4. Update the package.json file of your package with an appropriate name.
5. At the root directory, create a file to enable pnpm workspace functionality.
6. Update the scripts in your package.json to include a command that starts your new package.

</details>

<details>
<summary>🧰 Resources</summary>

- [pnpm workspaces](https://pnpm.io/workspaces): this link provides detailed information about how to use pnpm workspaces in a monorepo setup.

- [pnpm init](https://pnpm.io/cli/init): this link explains how to initialize a new project with pnpm, which is a crucial step in setting up a monorepo.

</details>

<details>
<summary>🌱 Solution</summary>

To set up a monorepo using pnpm workspaces, you need to follow these steps:

1. Navigate to the 01-start directory and create a new folder named packages:

```bash
cd 01-start
mkdir packages
```

2. Move into the packages folder and create a new package named firelane-one. Initialize this new package using pnpm init -y:

```bash
cd packages
mkdir firelane-one
cd firelane-one
pnpm init -y
```

The -y flag in pnpm init -y automatically fills in the default information in the package.json file.

3. Inside the firelane-one package, create a new file named index.js:

```js
touch index.js
```

4. In the package.json file of firelane-one, define the name of the package as "@forestpark/firelane-one". It should look like this:

```json
{
  "name": "@forestpark/firelane-one",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

The package.json file holds various metadata relevant to the project. The name property defines the name of the package, and the scripts property contains scripts that are run at various times in the lifecycle of your package.

5. Create a pnpm-workspace.yaml file at the root directory of 01-start. This file tells pnpm that you want to use workspace functionality.

```yaml
packages:
  - 'packages/**'
```

The line 'packages/**' tells pnpm to look for sub-modules inside the packages folder. The ** is a wildcard that matches any file or directory.

6. Update the scripts in your package.json file to include a command to start the @forestpark/firelane-one package:

```json
"scripts": {
  "firelane-one:start": "pnpm -r --filter @forestpark/firelane-one run start"
}
```

This script runs the start command defined in the package.json file of the @forestpark/firelane-one package. The -r flag tells pnpm to run the command recursively in every package in the monorepo, and the --filter @forestpark/firelane-one option limits the scope of the command to the @forestpark/firelane-one package.

</details>

## 04. Managing Multiple Packages and Executing Recursive Commands in a Monorepo

In a monorepo, managing multiple interconnected packages efficiently is crucial. One powerful tool that greatly enhances this process is the ability to execute commands recursively. This feature allows you to manage multiple packages as if they were a single entity, while still maintaining the independence and isolation of individual packages.

Running packages recursively in a monorepo is important for several reasons:

1. **Efficiency**: Executing commands across multiple packages with a single command saves time and reduces the potential for errors. Instead of manually running the same command for each package, you can do it all at once, significantly improving your workflow efficiency.

2. **Consistency**: By running the same command across all packages, you ensure that all parts of your project are in sync. This is particularly useful for tasks like testing or building, where consistency across packages is crucial. It ensures that all packages are tested or built with the same parameters, reducing inconsistencies and potential bugs.

3. **Flexibility**: Recursive commands can be filtered to target specific packages, giving you fine-grained control over which parts of your project are affected by a command. This is particularly useful when you want to run a command only on a subset of packages, allowing for more targeted and efficient operations.

In this section, we will explore how to run multiple packages and recursive commands in a monorepo. We will learn how to leverage these features to improve our monorepo management and make our development process more efficient and effective.

<details>
<summary>💪 Challenge</summary>

Your task is to create a second package in your monorepo and learn how to run scripts recursively.

1. Create a second package in your monorepo.

2. Add this function as the new package called `firelane-two`:

```js
function calculateHikingTime(trailLength, averageSpeed) {
  return trailLength / averageSpeed
}

let trailLength = 30 // length of the trail in miles
let averageSpeed = 3 // average hiking speed in miles per hour

console.log(
  `It would take approximately: `,
  calculateHikingTime(trailLength, averageSpeed),
  ' hours to hike this trail in Forest Park 🥾'
)
```

3. Run the package at the individual package level.

4. Run the package at the root of the monorepo recursively.

</details>

<details>

<summary>🧰 Resources</summary>

- https://pnpm.io/cli/recursive - Understand how to run commands recursively in a monorepo.

</details>

<details>

<summary>🌱 Solution </summary>

To create a second package in your monorepo, you'll first need to duplicate the `firelane-one` folder. Rename this duplicate to `firelane-two`. This gives you a new, separate package to work with.

Next, you'll want to ensure that `firelane-two` is running completely different code from `firelane-one`. To do this, update the `index.js` file in `firelane-two` with the `calculateHikingTime` function.

```js
function calculateHikingTime(trailLength, averageSpeed) {
  return trailLength / averageSpeed
}

let trailLength = 30 // length of the trail in miles
let averageSpeed = 3 // average hiking speed in miles per hour

console.log(
  `It would take approximately: `,
  calculateHikingTime(trailLength, averageSpeed),
  ' hours to hike this trail in Forest Park 🥾'
)
```

The `package.json` file in `firelane-two` needs to reflect the correct package name. Update the name in this file to `@forestpark/firelane-two`.

Finally, to run the second command from the root repository, you'll use the same `--filter` command as before. However, you need to update the name of the script and the package that the script is running. The updated script in the `package.json` file should look like this:

```json
{
  "name": "monorepo-forest",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "firelane-one:start": "pnpm -r --filter @forestpark/firelane-one run start",
    "firelane-two:start": "pnpm -r --filter @forestpark/firelane-two run start"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

If we execute these two command from the root directory of the monorepo, you will note that `pnpm run firelane-one:start` and `pnpm run firelane-two:start` excute two different packages.

The next step is to create a command inside `package.json` to run both packages recursively. You will do this by creating a third script using the `-r` flag provided by pnpm.

> The `-r` flag stands for "recursive". In the context of a monorepo, running a command recursively means that the command will be executed in each package that exists in the monorepo. This is a powerful feature that allows you to manage multiple packages as if they were a single entity, while still maintaining the independence and isolation of individual packages.

Your script should look like this, with the new start script for recurviely running all the packages:

```json
{
  "name": "monorepo-forest",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "firelane-one:start": "pnpm -r --filter @forestpark/firelane-one run start",
    "firelane-two:start": "pnpm -r --filter @forestpark/firelane-two run start",
    "start": "pnpm -r run start"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

When you execute the `start` script from the root directory of the monorepo, you should see both functions executing. You can do this by running the command `pnpm run start`.

This command will run the `start` script in each package that exists in the monorepo. As a result, you will see the output from both the `firelane-one` and `firelane-two` packages.

```bash
> monorepo-forest@1.0.0 start /Users/laurosilvacom/1-projects/monorepo-workshop/playground/02-start
> pnpm -r run start

Scope: 2 of 3 workspace projects
packages/firelane-one start$ node index.js
│ The tree has approximately:  7000  leaves 🍃
└─ Done in 79ms
packages/firelane-two start$ node index.js
│ It would take approximately:  10  hours to hike this trail in Forest Park 🥾
└─ Done in 77ms
laurosilvacom@laurosilvacom 02-start %
```

This demonstrates the power of running commands recursively in a monorepo, allowing you to manage multiple packages as if they were a single entity.

</details>

# Sharing Code Between Projects

Task: Run code from one package inside another package. Make each project into an ESM project. Install package number 2 into package 1. Run `pnpm install` and take a look at files in the node_modules folder.

Note: ESM stands for ECMAScript Modules. It's a standard for working with modules in JavaScript. Modules are reusable pieces of code that can be exported from one program and imported for use in another program. ESM is the official standard format to package JavaScript code for reuse. Modules are defined using a variety of import and export statements.

This is the core of working in a monorepo!

<details>
<summary>💪 Challenge</summary>

Your task is to:

1. Convert each project into an ESM (ECMAScript Modules) module.
2. Install the `firelane-two` package into the `firelane-one` package using `pnpm install`. You should be able to use `firelane-two` inside the same `index.js` file. You will need to adjust the code to be exported from `firelane-two`.
3. Explore the `node_modules` created at the root directory and in `package one`.

</details>

<details>
<summary>🧰 Resources</summary>

- [ECMAScript Modules (ESM) in Node.js](https://nodejs.org/api/esm.html): This link provides detailed information about how to use ESM in Node.js, which is crucial for converting your projects into ESM modules.

- [pnpm install](https://pnpm.io/cli/install): This link explains how to install packages using pnpm, which is necessary for installing `firelane-two` into `firelane-one`.

</details>

<details>
<summary>🌱 Solution</summary>

</details>

# Versioning and Workspace Pinning

Task: Change the code of the second package and update how it's being called in the first package. Enable pnpm to always grab the latest version of each package using `workspace:`

https://pnpm.io/workspaces

# Pinning Node and pnpm Versions

Task: Specify the version of Node and pnpm.

https://pnpm.io/package_json

# Installing Packages

Task: Install a third party dependency using pnpm. Not at the root of the workspace but at the specific project. Use the filter command of pnpm. Test that it runs correctly. Figure out if you get access to use this in other projects where the package is not installed. Why didn't it work?

```js
import snakeCase from 'just-snake-case'
;`snakeCase('the quick brown fox'); // 'the_quick_brown_fox'`
```

https://www.npmjs.com/package/just-snake-case

# Updating Packages and Version Syncing

Task: Versions can get complicated. How do we keep our versions up to date in our monorepo? Your task is to implement a script to update all your packages interactively. Update the dependencies to their latest stable version as determined by their latest tags.

https://pnpm.io/cli/update

# Installing Packages Into the Root

Task: Add this package at the root of the project using -w flag. Use this package in your project! You might think that this is a good approach for keeping dependencies up to date. It's not always the right decision to install it in the individual packages. There's no right answer for either installing packages at the root level or individual packages, it depends on your needs.

https://www.npmjs.com/package/just-kebab-case

# Cleaning node_modules

Task: Use the clean script using the find command and delete all node modules recursively.This is usefull if something is wrong and you need to install everything again.

# Understanding dependencies

Task: Use the pnpm list This command will output all the versions of packages that are installed, as well as their dependencies, in a tree-structure. Now use the why command Shows all packages that depend on the specified packag

https://pnpm.io/cli/why

https://pnpm.io/cli/list
import { version } from "react"

# Implementing Turborepo in Monorepo Projects

### Objective

Understand and apply the principles of managing a monorepo using Turborepo to optimize build systems, reduce complexity, and improve CI/CD efficiency.

# Exploring Turborepo

Task: Note the vision behind Turborepo, aiming to bring the advanced tooling used by FAANG companies to a wider audience with minimal configuration.

Learn about Turborepo's key features: Optimizing Scheduling, Incremental Execution, and Distributed Remote Caching.

# Setting Up Turborepo

Task: Configure Turborepo in your monorepo project, focusing on the pipeline declaration to relate package.json scripts with their cache outputs.

Explore the benefits of parallel execution and caching to speed up builds.

# Integrating with CI/CD and Remote Caching

Task: Set up GitHub Actions to work with Turborepo and Vercel's remote caching.

Create a personal access token in Vercel and configure your GitHub Actions workflow with TURBO_TOKEN and TURBO_TEAM environment variables.

# Collaborative Development with Turborepo

Task: Understand the concept of "Faster with Friends" and how Turborepo's caching mechanism can benefit collaborative development in a monorepo.

# Advanced Turborepo Techniques

Task: Apply Turborepo to optimize type checking and hot module reloading in a Next.js application with an external source folder.

Learn how to use the turbo ignore script to deploy only the applications that have changed, managing shared dependencies efficiently.
