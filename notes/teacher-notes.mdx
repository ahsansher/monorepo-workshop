# Monorepos and Forests ðŸŒ³

As a trail runner who loves exploring Forest Park in Portland, I've found a compelling metaphor for understanding Monorepos - the forest itself!

<details>
<summary>ðŸ“¸ Snapshot: Me running through Forest Park</summary>

![](../resources/images/000-intro-monorepos-forests.jpg)

</details>

Monorepos and forests share a striking similarity!

- Monorepos, like forests, thrive on interconnectedness. Just as trees in a forest are linked through a "wood-wide web" of fungal filaments, multiple projects coexist within a single monorepo, promoting efficient resource sharing and management.
- Trees communicate and adapt based on shared signals. Similarly, in a monorepo, changes in one part are instantly accessible to all other parts, enabling seamless collaboration.
- Monorepos simplify dependency management. All projects share the same dependencies, much like trees in a forest sharing water and nutrients through their interconnected network.
- The resilience of a monorepo mirrors that of a forest. The failure of one project doesn't mean disaster for the entire system, just as older "mother trees" nurture younger ones, ensuring the forest's survival and sustainability.

Join me as we traverse the forest of monorepos, discovering its interconnected pathways and hidden treasures!

# 01. Monorepo Architecture

A monorepo, short for monolithic repository, is a software development strategy where code for many projects is stored in the same repository. This approach is in contrast to having one repository per project, which is known as a polyrepo approach.

<details>
<summary>ðŸ’ª Challenge</summary>

Try to answer these questions based on your understanding of monorepos and code organization.

1. What are some potential benefits of orchestrating a monorepo? Think about aspects like code sharing, dependency management, and project synchronization.

2. What advantages might you gain from organizing your code into small, independent, and self-contained components with well-defined boundaries and interfaces? Consider factors like modularity, code maintainability, and testing.

</details>

<details>
<summary>ðŸŒ± Solution</summary>

### Scaling a Codebase

When it comes to scaling a codebase, companies face a crucial decision. They can either break their codebase into smaller, separate repositories (a strategy known as polyrepo), or they can consolidate their codebase into a single repository (a strategy known as monorepo).

### Polyrepo Strategy

![](../resources/images/001-polyrepo-strategy.png)

In a polyrepo approach, each application or service is maintained in its own separate repository. For instance, your main application would reside in one repository, while any shared services or libraries it uses, such as authentication or design systems, are stored in their respective repositories. These shared components are typically published to a package manager like NPM, allowing them to be easily included and updated across various projects.

> In simple terms, a polyrepo approach means using a separate repository for each team, application, or project, with each one having its own build process.

### Monorepo Strategy

![](../resources/images/002-monorepo-stratery.png)

A monorepo is a single repository that houses the code for multiple projects. These projects are distinct yet interconnected, and they often include related JavaScript or TypeScript packages. The projects within a monorepo can range from low-level utilities to high-level web user interfaces.

> The only difference is where you put your code. Itâ€™s probably a good idea to organize your code into small independent and self-contained components with well-defined boundaries and interfaces.

### Monorepo vs Monolith Clarified

A common misconception is that a monorepo and a monolithic application are the same. However, they differ significantly in structure. A monolithic application is essentially one large codebase that encompasses all its projects and components. On the other hand, a monorepo serves as a single repository that contains multiple, independent projects. This setup supports a modular approach to development, allowing each project to be developed separately yet still under the umbrella of a single version control system.

</details>

# 02. Introduction to pnpm

pnpm is a fast, efficient, and powerful package manager for JavaScript. It's an excellent alternative to npm, offering better monorepo tools and efficient package management. This section will guide you through the installation and usage of pnpm, helping you orchestrate a monorepo efficiently.

Why are we choosing this tool? It's an alternative to npm and the monorepo tools provided by pnpm are significantly better and more efficient. Some tools have too much bloat! With pnpm, you can orchestrate a monorepo efficiently. This is a workshop on using pnpm efficently as well!

<details>
<summary>ðŸ’ª Challenge</summary>

1. Your challange is to install pnpm. To verify your installation, check the version of pnpm installed. It should be `9` or the latest version.

</details>

<details>
<summary>ðŸ§° Resources</summary>

- [Motivation behind pnpm](https://pnpm.io/motivation)
- [Feature comparison between npm, yarn, and pnpm](https://pnpm.io/feature-comparison)
- [Installation guide for pnpm](https://pnpm.io/installation)

</details>

<details>

<summary>ðŸŒ± Solution</summary>
To install pnpm, use the following command:

```bash
brew install pnpm
```

After installation, ensure that you're using pnpm `9` or the latest version. You can do this by checking the installed version of pnpm:

```bash
pnpm --version
```

The output should be `9.0.6` or a later version.

```bash
9.0.6
```

</details>

# 02 Creating a Monorepo

We are going to focus on a barebones setup. We are not going to introduce any compilers, so that we can get the fundamentals down. Then, we can apply these to any project, whether that's a React, Svelte, or Vue framework.

<details>
<summary>ðŸ’ª Challenge</summary>

Your task is to create a monorepo using pnpm workspaces.

1. In the 01-start directory, create a new folder following monorepo conventions.
2. Inside this folder, initialize a new package.
3. Create an index.js file in your new package.
4. Update the package.json file of your package with an appropriate name.
5. At the root directory, create a file to enable pnpm workspace functionality.
6. Update the scripts in your package.json to include a command that starts your new package.

</details>

<details>
<summary>ðŸ§° Resources</summary>

- [pnpm workspaces](https://pnpm.io/workspaces): this link provides detailed information about how to use pnpm workspaces in a monorepo setup.

- [pnpm init](https://pnpm.io/cli/init): this link explains how to initialize a new project with pnpm, which is a crucial step in setting up a monorepo.

</details>

<details>
<summary>ðŸŒ± Solution</summary>

To set up a monorepo using pnpm workspaces, you need to follow these steps:

1. Navigate to the 01-start directory and create a new folder named packages:

```
cd 01-start
mkdir packages
```

2. Move into the packages folder and create a new package named firelane-one. Initialize this new package using pnpm init -y:

```
cd packages
mkdir firelane-one
cd firelane-one
pnpm init -y
```

The -y flag in pnpm init -y automatically fills in the default information in the package.json file.

3. Inside the firelane-one package, create a new file named index.js:

```
touch index.js
```

4. In the package.json file of firelane-one, define the name of the package as "@forestpark/firelane-one". It should look like this:

```json
{
  "name": "@forestpark/firelane-one",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

The package.json file holds various metadata relevant to the project. The name property defines the name of the package, and the scripts property contains scripts that are run at various times in the lifecycle of your package.

5. Create a pnpm-workspace.yaml file at the root directory of 01-start. This file tells pnpm that you want to use workspace functionality.

```yaml
packages:
  - 'packages/**'
```

The line 'packages/**' tells pnpm to look for sub-modules inside the packages folder. The ** is a wildcard that matches any file or directory.

6. Update the scripts in your package.json file to include a command to start the @forestpark/firelane-one package:

```
"scripts": {
  "firelane:start": "pnpm -r --filter @forestpark/firelane-one run start"
}
```

This script runs the start command defined in the package.json file of the @forestpark/firelane-one package. The -r flag tells pnpm to run the command recursively in every package in the monorepo, and the --filter @forestpark/firelane-one option limits the scope of the command to the @forestpark/firelane-one package.

</details>

# Multiple Package And Recursive Commands

Task: Create a second package and run scripts recursively. Orchestrate commands at the individual level or all of them at once.

# Sharing Code Between Projects

Task: Run code from one package inside another package. Make each project into an ESM project. Install package number 2 into package 1. Run `pnpm install` and take a look at files in the node_modules folder.

Note: ESM stands for ECMAScript Modules. It's a standard for working with modules in JavaScript. Modules are reusable pieces of code that can be exported from one program and imported for use in another program. ESM is the official standard format to package JavaScript code for reuse. Modules are defined using a variety of import and export statements.

This is the core of working in a monorepo!

# Versioning and Workspace Pinning

Task: Change the code of the second package and update how it's being called in the first package. Enable pnpm to always grab the latest version of each package using `workspace:`

https://pnpm.io/workspaces

# Pinning Node and pnpm Versions

Task: Specify the version of Node and pnpm.

https://pnpm.io/package_json

# Installing Packages

Task: Install a third party dependency using pnpm. Not at the root of the workspace but at the specific project. Use the filter command of pnpm. Test that it runs correctly. Figure out if you get access to use this in other projects where the package is not installed. Why didn't it work?

```js
import snakeCase from 'just-snake-case'
;`snakeCase('the quick brown fox'); // 'the_quick_brown_fox'`
```

https://www.npmjs.com/package/just-snake-case

# Updating Packages and Version Syncing

Task: Versions can get complicated. How do we keep our versions up to date in our monorepo? Your task is to implement a script to update all your packages interactively. Update the dependencies to their latest stable version as determined by their latest tags.

https://pnpm.io/cli/update

# Installing Packages Into the Root

Task: Add this package at the root of the project using -w flag. Use this package in your project! You might think that this is a good approach for keeping dependencies up to date. It's not always the right decision to install it in the individual packages. There's no right answer for either installing packages at the root level or individual packages, it depends on your needs.

https://www.npmjs.com/package/just-kebab-case

# Cleaning node_modules

Task: Use the clean script using the find command and delete all node modules recursively.This is usefull if something is wrong and you need to install everything again.

# Understanding dependencies

Task: Use the pnpm list This command will output all the versions of packages that are installed, as well as their dependencies, in a tree-structure. Now use the why command Shows all packages that depend on the specified packag

https://pnpm.io/cli/why

https://pnpm.io/cli/list
import { version } from "react"

# Implementing Turborepo in Monorepo Projects

### Objective

Understand and apply the principles of managing a monorepo using Turborepo to optimize build systems, reduce complexity, and improve CI/CD efficiency.

# Exploring Turborepo

Task: Note the vision behind Turborepo, aiming to bring the advanced tooling used by FAANG companies to a wider audience with minimal configuration.

Learn about Turborepo's key features: Optimizing Scheduling, Incremental Execution, and Distributed Remote Caching.

# Setting Up Turborepo

Task: Configure Turborepo in your monorepo project, focusing on the pipeline declaration to relate package.json scripts with their cache outputs.

Explore the benefits of parallel execution and caching to speed up builds.

# Integrating with CI/CD and Remote Caching

Task: Set up GitHub Actions to work with Turborepo and Vercel's remote caching.

Create a personal access token in Vercel and configure your GitHub Actions workflow with TURBO_TOKEN and TURBO_TEAM environment variables.

# Collaborative Development with Turborepo

Task: Understand the concept of "Faster with Friends" and how Turborepo's caching mechanism can benefit collaborative development in a monorepo.

# Advanced Turborepo Techniques

Task: Apply Turborepo to optimize type checking and hot module reloading in a Next.js application with an external source folder.

Learn how to use the turbo ignore script to deploy only the applications that have changed, managing shared dependencies efficiently.
